---------------------------------------------------------------------
midterm review
---------------------------------------------------------------------

---------------------------------------------------------------------
Problem 1: Implement a queue using two stacks. 
	-- queue: first in, first out. 
	-- stack: first in, last out. 

class Stack
{
	void push (int x); //adds to the TOP
	int pop(); //takes from the TOP
	bool isEmpty() //nothing in there
};


class Queue
{
public: 

	void enqueue (int x);  //adds to back
	int dequeue();         //takes from front

private: 
	Stack s1; 
	Stack s2;
};


//makes sure that s2 always has the entire queue on it. front
//stays on top of the queue, and we add to the bottom of s2
//by putting all of s2 on s1 and adding the new one to s2.
void Queue::enqueue(int x)
{
	//you always need to have the first entry at the top of one 
	//of the stacks. 

	if (s1.isEmpty() && s2.isEmpty()){
		s1.push(x);

	} else {
		
		while (!s2.isEmpty()) {
			s1.push(s2.pop()); //put all on s1 in reverse order
		}
		
		s2.push(x); // put the new x on s2 (the new bottom)
		
		while (!s1.isEmpty()) {
			s2.push(s1.pop()); //put reversed order back onto s1
		}
	}
}


int Queue::dequeue()
{
	return s2.pop();
}
---------------------------------------------------------------------
Problem 2: Mirror BST

class BST
{
public:

	void mirror();
	int count_leaves();
	void print();

private: 

	BSTNODE* rest;
};

struct BSTNODE
{
	int data;
	BSTNODE* left;
	BSTNODE* right;
};


void BST::mirror(BSTNODE* r)
{
	BSTNODE* temp = r->left;
	r->left = r->right;
	r->right = temp;

	r->right->mirror();
	r->left->mirror();
}


---------------------------------------------------------------------
Problem 3: Count leaves of BST

int BST::count_leaves()
{
	int sum = 0; 
	
	if (root->right == NULL && root->left == NULL){
		return 1;
	
	} else if (root->right != NULL && root -> left == NULL) {
		sum += root->right->count_leaves();
	
	} else if (root->left != NULL && root->right == NULL) {
		sum += root->left->count_leaves();
	
	} else {
		sum += root->right->count_leaves();
		sum += root->left->count_leaves();
	}
	return sum;
}

int BST::count_leaves(BSTNODE* r)
{
	if (r == NULL) {
		return 0; 
	} if (r->left == NULL && r->right == NULL) {
		return 1;
	} 
	return count_leaves(r->left) + count_leaves(r->right);
}


//call helper funcs here


---------------------------------------------------------------------
4. print out in order -- tree traverse (explore tree, print order)

void BST::print(BSTNODE* r)
{
	//print left
	//print self
	//print right

	print(r->left);
	cout << r->data;
	print(r->right);
}


---------------------------------------------------------------------

copy constructors...the learning that i never did before

LinkedList::LinkedList(const LinkedList &copy)
{
	
}